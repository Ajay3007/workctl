plugins {
    id 'application'
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

dependencies {
    implementation project(':core')
    implementation project(':config')
    implementation project(':agent')
    implementation 'info.picocli:picocli:4.7.5'
    annotationProcessor 'info.picocli:picocli-codegen:4.7.5'
}

compileJava {
    options.compilerArgs += ['-Aproject=com.workctl/workctl']
}

application {
    mainClass       = 'com.workctl.cli.WorkctlCLI'
    applicationName = 'workctl'
}

jar {
    manifest {
        attributes(
                'Main-Class':             application.mainClass.get(),
                'Implementation-Title':   'workctl CLI',
                'Implementation-Version': version
        )
    }
}

distributions {
    main {
        distributionBaseName = 'workctl'
    }
}

// ── OS detection (must be before any task that references isWindows) ──
ext {
    isWindows      = org.gradle.internal.os.OperatingSystem.current().isWindows()
    isMacOS        = org.gradle.internal.os.OperatingSystem.current().isMacOsX()
    platformSuffix = isWindows ? "windows" : isMacOS ? "macos" : "linux"
}

// ── Auto-regenerate shell completion after every installDist ──────
// Keeps ~/.workctl/workctl_completion in sync whenever new commands are added.
// Bash/zsh only — skipped on Windows (PowerShell completion not yet supported).
tasks.register('generateCompletion', Exec) {
    group       = 'workctl distribution'
    description = 'Regenerate ~/.workctl/workctl_completion after installDist (macOS/Linux only)'
    dependsOn   installDist

    def completionFile = file("${System.getProperty('user.home')}/.workctl/workctl_completion")
    def workctlBin     = file("${buildDir}/install/workctl/bin/workctl")

    if (isWindows) {
        // No-op on Windows — bash/zsh completion not applicable
        commandLine 'cmd', '/c', 'echo Skipping completion generation on Windows (bash/zsh not available). To use completions in Git Bash or WSL run: workctl generate-completion bash > ~/.workctl/workctl_completion'
    } else {
        completionFile.parentFile.mkdirs()
        // Generate base completion then append dynamic project-name patch
        commandLine 'sh', '-c', """
            \"${workctlBin.absolutePath}\" generate-completion bash > \"${completionFile.absolutePath}\"
            cat >> \"${completionFile.absolutePath}\" << 'PATCH'

# ── Dynamic project name completion ─────────────────────────────────────────
# Appended by Gradle generateCompletion. Reads live project names from the
# workspace at tab-press time so completions always reflect reality.
_workctl_project_names() {
    workctl project list 2>/dev/null \\
        | grep '^ *-' \\
        | sed 's/^ *- *//'
}

# Wrapper around the picocli-generated _complete_workctl.
# Intercepts only the <project> positional argument for each command;
# everything else (flags, subcommand names, option values) is handled
# by the original picocli function unchanged.
_complete_workctl_dynamic() {
    local cmd="\${COMP_WORDS[1]}"
    local cword=\$COMP_CWORD
    local cur="\${COMP_WORDS[COMP_CWORD]}"

    case "\$cmd" in
        insight|stats|weekly|log|ask)
            # workctl <cmd> <project>  →  project is at position 2
            if [[ \$cword -eq 2 && "\$cur" != -* ]]; then
                COMPREPLY=(\$(compgen -W "\$(_workctl_project_names)" -- "\$cur"))
                return
            fi
            ;;
        task)
            # workctl task <subcmd> <project>  →  project is at position 3
            if [[ \$cword -eq 3 && "\$cur" != -* ]]; then
                COMPREPLY=(\$(compgen -W "\$(_workctl_project_names)" -- "\$cur"))
                return
            fi
            ;;
        project)
            # workctl project delete <project>  →  project is at position 3
            if [[ \$cword -eq 3 && "\${COMP_WORDS[2]}" == "delete" && "\$cur" != -* ]]; then
                COMPREPLY=(\$(compgen -W "\$(_workctl_project_names)" -- "\$cur"))
                return
            fi
            ;;
    esac

    # Fall back to picocli-generated completion for everything else
    _complete_workctl
}

# Replace the picocli binding with our dynamic wrapper
complete -F _complete_workctl_dynamic workctl
PATCH
        """
    }

    doLast {
        if (!isWindows) println "✓ Completion script updated → ${completionFile}"
    }
}

installDist.finalizedBy generateCompletion

// ── Delete previous package (cross-platform) ─────────────────────

tasks.register('cleanPackage') {
    group       = 'workctl distribution'
    description = 'Delete previous jpackage output'
    doLast {
        def appDir = file("${rootDir}/build/release/workctl")
        if (appDir.exists()) {
            if (isWindows) {
                exec { commandLine 'cmd', '/c', "rmdir /s /q \"${appDir.absolutePath}\"" }
            } else {
                exec { commandLine 'rm', '-rf', appDir.absolutePath }
            }
            println "  Deleted: ${appDir}"
        }
        file("${rootDir}/build/release").mkdirs()
    }
}

// ── Package as native app (cross-platform) ───────────────────────
//
// Windows → build/release/workctl/workctl.exe
// macOS   → build/release/workctl/workctl
// Linux   → build/release/workctl/workctl
//
// Run:    ./gradlew :cli:packageNative
// Target machine needs: nothing (no Java required)

tasks.register('packageNative', Exec) {
    group       = 'workctl distribution'
    description = 'Package CLI as native executable — no Java needed on target machine'
    dependsOn   installDist, cleanPackage

    doFirst {
        def outDir = file("${rootDir}/build/release")
        outDir.mkdirs()
        def libDir = file("${buildDir}/install/workctl/lib").absolutePath

        def cmd = [
                'jpackage',
                '--type',         'app-image',
                '--name',         'workctl',
                '--app-version',  version,
                '--input',        libDir,
                '--main-jar',     "cli-${version}.jar",
                '--main-class',   application.mainClass.get(),
                '--dest',         outDir.absolutePath,
                '--win-console',  // keeps terminal output visible (ignored on macOS/Linux)
        ]

        // macOS: required bundle identifier
        if (isMacOS) {
            cmd += ['--mac-package-identifier', 'com.workctl.cli']
        }

        commandLine = cmd
        println "  Building CLI for: ${isWindows ? 'Windows' : isMacOS ? 'macOS' : 'Linux'}"
    }

    doLast {
        def exe = isWindows ? 'workctl/workctl.exe' : 'workctl/workctl'
        println ""
        println "✓ CLI packaged → build/release/${exe}"
        println "  No Java needed on the target machine."
    }
}

// ── Zip installDist output (for users who have Java 17+) ─────────
// Smaller than packageNative (no bundled JRE), but requires Java on target.
//
// Run:    ./gradlew :cli:zipDist

tasks.register('zipDist', Zip) {
    group               = 'workctl distribution'
    description         = 'Zip installDist output (requires Java 17+ on target)'
    dependsOn           installDist

    archiveFileName             = "workctl-${version}-dist-${platformSuffix}.zip"
    destinationDirectory        = layout.buildDirectory.dir('distributions')

    from(installDist.destinationDir)
    into("workctl-${version}")

    doLast {
        println "✓ CLI dist → cli/build/distributions/workctl-${version}-dist-${platformSuffix}.zip"
        println "  Requires Java 17+ on target."
        println "  Run: workctl-${version}/bin/workctl${isWindows ? '.bat' : ''} <command>"
    }
}

// ── Zip the native package for sharing ───────────────────────────
// Run:    ./gradlew :cli:packageZip

tasks.register('packageZip', Zip) {
    group               = 'workctl distribution'
    description         = 'Zip the native CLI package for sharing (no Java needed)'
    dependsOn           packageNative

    archiveFileName             = "workctl-${version}-${platformSuffix}.zip"
    destinationDirectory        = layout.buildDirectory.dir('distributions')

    from("${rootDir}/build/release/workctl")
    into("workctl-${version}")

    doLast {
        println "✓ CLI zip → cli/build/distributions/workctl-${version}-${platformSuffix}.zip"
        println "  No Java needed. Extract and run workctl-${version}/workctl${isWindows ? '.exe' : ''}"
    }
}
